# Упражнение 10 - Индекси и изгледи

## Индекс
Обект в базата от данни, който помага за организирането на данните и ускоряването на изпълнението на заявките.

- Създава се за изгледи и таблици
- Подпомага подреждането на данните
- Използва указатели към адреси в паметта

Реализира се с балансирано дърво. Всеки възел, който не е листо, има n ключа и n+1 указателя.
Ключовете дефинират интервал от стойности, в който се намират
ключовете на наследниците на възела. Стойностите са сортирани.

### Типове

- Уникални и неуникални
- Клъстерирани (първичен)

Отговаря за физическото съхранение на данниите. В листата имаме страниците от данни подредени по ключовите атрибути.

Една таблица може да има само един клъстериран индекс

- Неклъстериран (вторичен)

В листата на дървото имаме указател към страниците от данни.

Индексът е отделен от физическото съхранение на данните.

- Прост
  
Индексът е изграден по един атрибут

- Съставен
  
Изграден от повече от по един атрибут

### Създаване

*СЛЕД СЪЗДАВАНЕ НЕ МОЖЕ ДА СЕ МОДИФИЦИРА (само може да се изтрие)*

- Експлицитно

```sql
CREATE [UNIQUE | CLUSTERED | NONCLUSTERED]
INDEX index_name
ON table(column[,column]...);
```
- Имплицитно - при създаване на Primary Key или
Unique ограничение

### Изтриване

Индексът е отделен обект от таблицата, но като изтрием таблицата се изтрива и индекса.

```sql
DROP INDEX table_name.index_name;
--или
DROP INDEX index_name ON table_name;
```

*Кога създаваме индекси?* - Ако данните в таблицата се променят рядко. 
Ако колоната има голям брой различни стойности.
Кандидати за индексиране са атрибути, които често се намират в GROUP BY, ORDER BY клаузите

*Кога не създаваме индекси?* - При малка таблица и в обратните случаи на горния. Недостатък -
Забавят и усложняват DML операциите, защото след като
промени таблиците, СУБД трябва да промени и индекса  

## Изгледи

Виртуални (логически) таблици - не се намират физически върху диска.
Създават се, за да извличаме, модифицираме данни от базовите таблици (може да се създадат от друг изглед).
Съхраняват се като SELECT оператор в списъка на данни

Използваме за: ограничаване на достъпа на данни, осигуряване на независимост на структурата на данни, за "преименуване" и "пренареждане" на данни
Могат да се използват като обикновени таблици в
SELECT, INSERT, UPDATE и DELETE оператори.

### Типове
- Сложни изгледи - върху повече от 1 таблица, *САМО ЗА ЧЕТЕНЕ*

  Съдържат функции, групирани данни. Понякога могат да се изпълняват DML операции върху тях
- Прости изгледи - върху 1 таблица

### Създаване

```sql
CREATE VIEW <name>(alias) --може да се даде прякор и в подзаявката, но ако съществуват и двете това тук остава накрая
AS <subquery>
[WITH CHECK OPTION];
```

`WITH CHECK OPTION` указва, че всеки `INSERT` или `UPDATE` чрез изгледа (VIEW) трябва да удовлетворява условията на `WHERE` клаузата (на подзаявката) на изгледа.

### Изтриване

```sql
DROP VIEW view_name;
```

### Промяна на изглед

```sql
ALTER VIEW <view_name> [(alias[,alias]...)]
AS <subquery>
[WITH CHECK OPTION];

--или с DROP + CREATE
```
### Модифициране на данни

*АКО МОДИФИЦИРАМЕ ИЗГЛЕДА, МОДИФИЦИРАМЕ И БАЗОВАТА ТАБЛИЦА*

Модификацията ще се изпълни, ако отговаря на WHERE клаузата. Ако разрешават NULL, могат да се пропуснат

Модифициране на данни чрез изглед:

|             | GROUP FUNC | GROUP BY | DISTINCT | Computed column |
|-------------|------------|----------|----------|-----------------|
| **DELETE**  | ❌         | ❌      | ❌       | ✅             |
| **INSERT**  | ❌         | ❌      | ❌       | ❌             | 
| **UPDATE**  | ❌         | ❌      | ❌       | ❌             |
